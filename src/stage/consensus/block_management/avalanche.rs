use super::BlockManagement;
use crate::config::AvalancheConfig;

use crate::protocol::block::{Block, BlockHeader};
use crate::protocol::crypto::{sha256, Hash};
use crate::protocol::transaction::{AvalancheTxn, Txn};
use crate::protocol::CryptoScheme;
use crate::utils::{CopycatError, NodeId};

use async_trait::async_trait;
use primitive_types::U256;

use tokio::sync::Notify;
use tokio::time::{Duration, Instant};

use std::collections::HashMap;
use std::sync::Arc;

pub struct AvalancheBlockManagement {
    id: NodeId,
    crypto_scheme: CryptoScheme,
    blk_len: usize,
    txn_pool: HashMap<Hash, Arc<Txn>>,
    txn_dag: HashMap<Hash, Vec<Hash>>,
    // fields for constructing new block
    blk_counter: u64,
    curr_batch: Vec<Hash>,
    next_propose_time: Instant,
    proposal_timeout: Duration,
    _notify: Notify,
}

impl AvalancheBlockManagement {
    pub fn new(id: NodeId, crypto_scheme: CryptoScheme, config: AvalancheConfig) -> Self {
        let proposal_timeout = Duration::from_secs_f64(config.proposal_timeout_secs);
        Self {
            id,
            crypto_scheme,
            blk_len: config.blk_len,
            txn_pool: HashMap::new(),
            txn_dag: HashMap::new(),
            // for batching txns into blocks
            blk_counter: 0,
            curr_batch: vec![],
            next_propose_time: Instant::now() + proposal_timeout,
            proposal_timeout,
            _notify: Notify::new(),
        }
    }
}

impl AvalancheBlockManagement {
    fn validate_txn(&self, txn: &AvalancheTxn) -> Result<bool, CopycatError> {
        match txn {
            AvalancheTxn::Send {
                sender: txn_sender,
                in_utxo: txn_in_utxo,
                out_utxo: txn_out_utxo,
                remainder: txn_remainder,
                ..
            } => {
                let mut input_value = 0;
                for in_utxo_hash in txn_in_utxo.iter() {
                    // first check that input transactions exists, we can check for double spend later as a block
                    // add values together to find total input value
                    let utxo = match self.txn_pool.get(in_utxo_hash) {
                        Some(txn) => match txn.as_ref() {
                            Txn::Avalanche { txn } => txn,
                            _ => unreachable!(),
                        },
                        None => return Ok(false), // invalid utxo
                    };

                    let value = match utxo {
                        AvalancheTxn::Grant { out_utxo, receiver } => {
                            if receiver == txn_sender {
                                out_utxo
                            } else {
                                return Ok(false); // utxo does not belong to sender
                            }
                        }
                        AvalancheTxn::Send {
                            sender,
                            receiver,
                            out_utxo,
                            remainder,
                            ..
                        } => {
                            if receiver == txn_sender {
                                out_utxo
                            } else if sender == txn_sender {
                                remainder
                            } else {
                                return Ok(false); // utxo does not belong to sender
                            }
                        }
                        AvalancheTxn::Noop { .. } | AvalancheTxn::PlaceHolder => {
                            unreachable!();
                        }
                    };
                    input_value += value;
                }

                // check if the input values match output values
                if input_value != txn_out_utxo + txn_remainder {
                    return Ok(false); // input and output utxo values do not match
                }
            }
            AvalancheTxn::Grant { .. } | AvalancheTxn::Noop { .. } => {
                // grant txns are always correct
                // noops are generated by other nodes to drive consensus and does nothing
            }
            AvalancheTxn::PlaceHolder => {
                unreachable!();
            }
        }

        Ok(true)
    }
}

#[async_trait]
impl BlockManagement for AvalancheBlockManagement {
    async fn record_new_txn(&mut self, txn: Arc<Txn>) -> Result<bool, CopycatError> {
        let txn_hash = sha256(&bincode::serialize(txn.as_ref())?)?;
        // ignore duplicates
        if self.txn_pool.contains_key(&txn_hash) {
            return Ok(false);
        }

        let avax_txn = match txn.as_ref() {
            Txn::Avalanche { txn } => txn,
            _ => unreachable!(),
        };

        if !self.validate_txn(avax_txn)? {
            return Ok(false);
        }

        self.txn_pool.insert(txn_hash.clone(), txn.clone());

        let parents = match avax_txn {
            AvalancheTxn::Grant { .. } => vec![],
            AvalancheTxn::Send { in_utxo, .. } => in_utxo.clone(),
            AvalancheTxn::Noop { .. } | AvalancheTxn::PlaceHolder => unreachable!(), // since Noops are generated by nodes only
        };
        self.txn_dag.insert(txn_hash, parents);

        Ok(true)
    }

    async fn prepare_new_block(&mut self) -> Result<(), CopycatError> {
        let mut curr_batch: Vec<U256> = vec![];
        for (txn_hash, parents) in self.txn_dag.iter() {
            // do not add more txns if current batch is full
            if self.curr_batch.len() + curr_batch.len() >= self.blk_len {
                break;
            }

            // first check if all the parents are emitted
            let mut in_frontier = true;
            for parent in parents {
                if self.txn_dag.contains_key(parent) && !curr_batch.contains(parent) {
                    in_frontier = false;
                    break;
                }
            }

            if !in_frontier {
                continue;
            }

            // it is ok if a batch contains conflict txns - they are voted independently
            curr_batch.push(txn_hash.clone());
        }

        // remove txns in curr_batch from txn_dag
        self.txn_dag
            .retain(|txn_hash, _| !curr_batch.contains(txn_hash));
        // add new txns to self.curr_batch
        self.curr_batch.extend(curr_batch);

        Ok(())
    }

    async fn wait_to_propose(&self) -> Result<(), CopycatError> {
        if self.curr_batch.len() == 0 {
            // TODO: add noop txns so that parent txns can get voted on
            // sleep forever
            loop {
                self._notify.notified().await;
            }
        } else if self.curr_batch.len() >= self.blk_len {
            return Ok(());
        } else {
            tokio::time::sleep_until(self.next_propose_time).await;
            return Ok(());
        }
    }

    async fn get_new_block(&mut self) -> Result<Arc<Block>, CopycatError> {
        //TODO: add noop txns to drive consensus as needed
        let txn_hashs: Vec<Hash> = self.curr_batch.drain(0..).collect();
        let txns = txn_hashs
            .iter()
            .map(|txn_hash| self.txn_pool.get(&txn_hash).unwrap().clone())
            .collect();
        let header = BlockHeader::Avalanche {
            proposer: self.id,
            id: self.blk_counter,
        };
        pf_debug!(self.id; "sending block query {:?} ({} txns)", header, txn_hashs.len());
        let blk = Arc::new(Block { header, txns });
        self.blk_counter += 1;
        self.next_propose_time = Instant::now() + self.proposal_timeout;
        Ok(blk)
    }

    async fn validate_block(&mut self, block: Arc<Block>) -> Result<Vec<Arc<Block>>, CopycatError> {
        let mut filtered_txns = vec![];
        for txn in block.txns.iter() {
            let txn_hash = sha256(&bincode::serialize(txn.as_ref())?)?;

            if self.txn_pool.contains_key(&txn_hash) {
                // txn has been validated before
                filtered_txns.push(txn.clone());
                continue;
            }

            // I have not seen this txn before, adding to txn_pool and txn_dag so that it will get proposed later
            let avax_txn = match txn.as_ref() {
                Txn::Avalanche { txn } => txn,
                _ => unreachable!(),
            };

            match avax_txn {
                AvalancheTxn::Noop { .. } | AvalancheTxn::PlaceHolder => {
                    // if noop txn, bypass all tests since it is just used to drive consensus
                    // placeholder txns should not be sent across nodes but if this is the case, keep as is
                    // they do not need to be add to txn pool
                    filtered_txns.push(txn.clone());
                }
                AvalancheTxn::Grant { .. } => {
                    filtered_txns.push(txn.clone());
                    self.txn_pool.insert(txn_hash.clone(), txn.clone());
                    self.txn_dag.insert(txn_hash, vec![]);
                }
                AvalancheTxn::Send {
                    sender,
                    in_utxo,
                    sender_signature,
                    ..
                } => {
                    // verify signature
                    let serialized_in_txo = bincode::serialize(in_utxo)?;
                    let mut valid = !self
                        .crypto_scheme
                        .verify(sender, &serialized_in_txo, sender_signature)
                        .await?;

                    // verify validity
                    if valid {
                        valid = self.validate_txn(avax_txn)?;
                    }

                    if valid {
                        // add to txn pool if valid
                        filtered_txns.push(txn.clone());
                        self.txn_pool.insert(txn_hash.clone(), txn.clone());
                        self.txn_dag.insert(txn_hash, in_utxo.clone());
                    } else {
                        // otherwise put a place holder
                        filtered_txns.push(Arc::new(Txn::Avalanche {
                            txn: AvalancheTxn::PlaceHolder,
                        }));
                    }
                }
            }
        }

        assert!(filtered_txns.len() == block.txns.len());

        let blk = Arc::new(Block {
            header: block.header.clone(),
            txns: filtered_txns,
        });
        Ok(vec![blk])
    }

    async fn handle_pmaker_msg(&mut self, _msg: Arc<Vec<u8>>) -> Result<(), CopycatError> {
        todo!();
    }

    async fn handle_peer_blk_req(
        &mut self,
        _peer: NodeId,
        _blk_id: Hash,
    ) -> Result<(), CopycatError> {
        unreachable!();
    }
}
